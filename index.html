<!DOCTYPE html>
<!--

She's a beaut, isn't she?

-->
<html>
    <head>
        <title>EmmaPHP</title>
        
        <meta name="viewport" content="width=device-width, user-scalable=yes">
                
		<link rel="icon" href="heart.ico">

        <!--css-->
        <link href='http://fonts.googleapis.com/css?family=Lobster' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Didact+Gothic' rel='stylesheet' type='text/css'>
        <link href="style.css" rel="stylesheet" type="text/css" />
        <!--css end-->
        
        <!--jquery-->
        <script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>
        <!--jquery end-->
        
        <!--script-->
        <script>
        
            function download() {
                
                window.location = "https://github.com/bobdesaunois/EmmaPHP/releases";
                
            }
            
            function userGuide() {
                
                $("html, body").animate(
                    {"scrollTop" : document.getElementById("section_2").offsetTop}, 
                    {duration: 250, queue: false}
                );
                
            }
            
            function moveTo(element) {
                
                $("html, body").animate(
                    {"scrollTop" : document.getElementById(element).offsetTop}, 
                    {duration: 250, queue: false}
                );
                
            }
        
        </script>
        <!--script end-->
        
    </head>
    <body>
        
	<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-52319357-1', 'auto');
        ga('send', 'pageview');

    </script>

        <!--wrapper-->
        <div id="wrapper">
            
            <!--section_1-->
            <div class="section" id="section_1">
                
                Version <b>1.2.1 Beta</b>
                
                <!--section_1_content-->
                <div class="content" id="section_1_content">
                    
                    <!--title-->
                    <div class="center" id="title">EmmaPHP</div>
                    <!--title end-->
                    
                    <!--description-->
                    <div class="center" id="description">
                        The cutest PHP MVC Framework out there.
                    </div>
                    <!--description end-->
                    
                    <!--download-->
                    <div id="download">
                        
                        <button id="download_button" onclick="download();">Download</button><br/><br/>
                        
                        <a href="#user_guide" id="dwnlwd" onclick="userGuide();">or click here to take a look at our user guide!</a>
                        
                    </div>
                    <!--download end-->
                    
                </div>
                <!--section_1_content end-->
                
            </div>
            <!--section_1 end-->
            
            <!--section_2-->
            <div class="section" id="section_2">
                
                <div class="content" id="section_2_content">
                
                    <small>
                    
                    <h1 class="pink">User Guide Index</h1>
                    <ul>
                        
                        <li><a href="#configuration"><b>Configuration</b></a></li>
                            <ul>
                                <li>Files</li>
                            </ul>
                        <br/>
                        
                        <li><a href="#controllers"><b>Controllers</b></a></li>
                            <ul>
                                <li>Index</li>
                                <li>Controller creation</li>
                                <li>Naming</li>
                                <li>Base controller</li>
                            </ul><br/>
                            
                        <li><a href="#models"><b>Models</b></a></li>
                            <ul>
                                <li>Model creation</li>
                                <li>Naming</li>
                                <li>Base model</li>
                                <li>Loading models</li>
                                <li>Interacting with the Database</li>
                                    <ul>
                                        <li>Using PDO</li>
                                        <li>Using the Base Model</li>
                                    </ul><br/>
                                <li>DataObjects</li>
                                <li>Using your homemade model</li><br/>
                            </ul>
                        <li><a href="#views"><b>Views</b></a></li>
                        <ul>
                            <li>View creation</li>
                            <li>Linking CSS & JavaScript</li>
                            <li>Loading views</li>
                            <li>Accessing data through views</li>
                        </ul>
						<br/>
						<li><a href="#parameters"><b>Parameters</b></a></li>
						<li><a href="#redirecting"><b>Redirecting</b></a></li>
						<li><a href="#sessions"><b>Sessions</b></a></li>
                        <li><a href="#security"><b>Security</b></a></li>
                        <li><a href="#mods"><b>Mods</b></a></li>
                    </ul>
                
                    <!--configuration-->
                    <div class="ug_item" id="configuration">
                        <h1 class="pink">Configuration</h1><br/>
                        <h2><b>Files</b></h2><br/>
                        There are a few files dedicated to holding configuration settings.<br/>
                        config/application_config.php is for setting the default controller, debug mode and the session.<br/>
                        while config/database.php is for setting all database variables.<br/>
                        Then there's config/config,<br/>
						<b>It is very important that the EmmaPHP framework knows where it is.</b><br/>
						Please set the "BASEPATH" constant to the URL location of the framework.<br/>
                        You can set the "TITLE" constant to whatever you wish to be the title in the HTML head.<br/>
                        and then there's the <span class="pink">AutoLoader</span>'s array, more about that in the <span class="pink">AutoLoader</span>'s section.

                    </div>
                    <!--configuration end-->
                    
                    <!--controllers-->
                    <div class="ug_item" id="controllers">
                        
                        <h1 class="pink">EmmaPHP::Controllers</h1><br/>
                        <h2><b>Controller creation</b></h2><br/>
                        Here's a short example of what a controller would look like<br/>
                        within the <span class="pink">EmmaPHP Framework</span>.<br/><br/>
<pre>
class WelcomeController extends EmmaController {
    
    function __construct () {
        
        parent::__construct ();
        
    }
    
    public function index () {
        
        $this->page ();
        
    }
    
    public function page ($page = "welcome") {
        
        if( ! file_exists ("views/pages/" . $page . ".php")) {
            
            $this->show_404 ();
            
        } else {
            
            $this->load->view ("templates/header.php");
            $this->load->view ("pages/" . $page . ".php");
            $this->load->view ("templates/footer.php");
            
        }
        
    }
    
}
</pre>
                        <br/>
                        
                        <h2><b>Index</b></h2><br/>
                        If a method was not supplied through the URL then the controller<br/>
                        will always -- if exists, run a public <span class="pink">index()</span> method.<br/>
                        Use the <span class="pink">index()</span> method as the index of your controller.<br/>
                        <b>Note that the <span class="pink">index()</span> method and <span class="pink">constructor</span> are obligatory,<br/>
                        you must have a <i>public</i> index method in your controller just like you must have a constructor.</b>
                        <br/>
                        <br/>
                        <h2><b>Naming</b></h2><br/>
                        Both naming of the file and the class of the controller<br/>
                        is very important, this controller is the <span class="pink">Welcome controller</span>.<br/>
                        The file would be named in lower-case <span class="pink">"welcome.php"</span>,<br/>
                        while the class is named <span class="pink">WelcomeController</span>.<br/>
                        <br/>
                        It's very important that the class name starts with a capitol<br/>
                        like you would do anywhere else.<br/>
                        And it's important that you add <span class="pink">"Controller"</span> as suffix.<br/>
<!--                        In contradiction to homemade controllers it <b>does matter</b> when you are extending.<br/>
                        you should never extend <span class="pink">"Emma_<b>c</b>ontroller"</span> but instead <b>always</b> extend <span class="pink">"Emma_<b>C</b>ontroller"</span>-->
                        <br/>
                        
                        <h2><b>Base controller</b></h2><br/>
                        Then there's adding your homemade controller<br/> as a child to the parent controller <span class="pink">EmmaController</span>.<br/>
                        Believe it or not but your homemade Controller <b>will actually run</b><br/>
                        if you do not extend it to <span class="pink">EmmaController</span>.<br/>
                        You will however not be able to benefit of any of the system's functionallity.<br/>
                        Which ultimately defeats the purpose of using a Framework.<br/>
                        Therefore you should <b>always</b> make sure your homemade controller<br/>
                        does infact extends the <span class="pink">EmmaController</span>.<br/>
                        <br/>
                        Last but not least make sure that you run the parent's constructor<br/>
                        in your homemade controllers constructor before you do anything.<br/>
                        Like so:<br/><br/>
<pre>
function __construct () {
        
    parent::__construct ();

}
</pre>
                        
                    </div>
                    <!--controllers end-->
                    
                    <!--models-->
                    <div id='models' class='ug_item'>
                        
                        <h1 class='pink'>EmmaPHP::Models</h1><br/>
                        
                        <h2>Model creation</h2><br/>
                        Consider a model called <span class="pink">DataModel</span>.<br/>
                        <br/>
<pre>
class DataModel extends EmmaModel {
    
    function __construct () {
        
        parent::__construct ();
        
    }
    
    public function getData ($id) {
        
        $sql =    "SELECT information_string "
                . "FROM DATA "
                . "WHERE id = ? "
                . "LIMIT 1;";
        
        $result = $this->fetch ($sql, array ($id));

        return $result ? $result->data_column : false;
        
    }

}
</pre><br/>
                        <br/>
                        <h2><b>Naming</b></h2><br/>
                        Much like we would create a controller you would create a model.<br/>
                        The file would be named <span class="pink">"data.php"</span>,<br/>
                        where as the class name would be <span class="pink">"DataModel"</span>.<br/>
                        <br/>
                        Again It's very important that the class name starts with a capital<br/>
                        like you would do anywhere else.<br/>
                        And it's important that you add <span class="pink">"Model"</span> as suffix.<br/>
                        <br/>
                        <br/>
                        
                        <h2><b>Base model</b></h2><br/>
                        Then there's adding your homemade model<br/>
                        as a child to the parent model <span class="pink">EmmaModel</span>.<br/>
                        Believe it or not but your homemade model will actually run<br/>
                        if you do not extend it to <span class="pink">EmmaModel</span>.<br/>
                        However you will not be able to benefit off of the database<br/>
                        and it's child connection object.<br/>
                        Which ultimately defeats the purpose of using a Model or a Framework.<br/>
                        Therefore you should always make sure your homemade model<br/>
                        does infact extends the <span class="pink">EmmaController</span>.<br/>
                        <br/>
                        Last but not least make sure that you run the parent's constructor<br/>
                        in your homemade models constructor before you do anything.<br/>
                        Like so:<br/><br/>
<pre>
function __construct () {
        
    parent::__construct ();

}
</pre><br/>
                        <br/>
                        
                        <h2><b>Loading models</b></h2><br/>
                        We may load models into our controllers by use of a function supplied by the loader object: <span class="pink">$this->load</span>.<br/>
                        Assume we would have created a model called <span class="pink">"UserModel"</span>,<br/>
                        this would be it's <b>class name</b> it's filename would be <span class="pink">"user.php"</span>.<br/>
                        I advise you to load all your models <b>after</b> the parent constructor.<br/>
                        We do this as following:<br/><br/>
<pre>
function __construct () {
        
    parent::__construct ();

    $this->load->model ("UserModel");

}
</pre><br/>
                        You would notice that <b>we load models by class name and not by filename</b>.<br/>
                        <br/>
                        
                        <h2><b>Interacting with the Database</b></h2><br/>
                        
                        There are two ways of interacting with the Database<br/>
                        within the <span class="pink">EmmaPHP Framework</span>.<br/>
                        There's <b>using the database class</b> and <b>using PDO</b>.<br/>
                        The <span class="pink">EmmaPHP Framework</span> does <b>NOT</b> use MySQL or MySQLi extensions.<br/>
                        That is for a good reason and you shouldn't be using them either.<br/>
                        <br/>
                        <h3><b>Using PDO</b></h3><br/>
                        You can apply PDO within your model just like you would<br/>
                        anywhere else.<br/>
                        The only thing that would change is preparing statements.<br/>
                        You are to retrieve the <span class="pink">db</span> object and it's child <span class="pink">connection</span> object before you do so.<br/>
                        Consider the following code:<br/><br/>
<pre>
$sql =    "SELECT information_string "
        . "FROM DATA "
        . "LIMIT 1;";

$stmt = $this->db->connection->prepare($sql);
$stmt->execute();

$result = $stmt->fetch(PDO::FETCH_ASSOC);
$stmt->closeCursor();

return $result ? $result : false;
</pre><br/>
                        <br/>
                        Like stated before; nothing changes except preparing a statement.<br/>
                        You are to retrieve the <span class="pink">db</span> object from the local scope to then retrieve<br/>
                        it's child object <span class="pink">connection</span> to then use the <span class="pink">prepare ()</span> method.<br/>
                        
                        
                        <br/>
                        <h3><b>Using the Base Model</b></h3><br/>
                        Interacting with the Database using the <span class="pink">Base Model</span> makes this task easier than ever.<br/>
						Your homemade model inherits a set of functions from the <span class="pink">Base Model</span>.<br/>
						These functions are <span class="pink">query ()</span>, <span class="pink">fetch ()</span> and <span class="pink">fetchAll ()</span>.<br/>
						They all work exactly the same, you supply a SQL query and the parameters if neccesary.<br/>
						<br/>
						Were we to run a query to a database we'd do so as following:<br/><br/>
<pre>
$sql = "DELETE * FROM users";

$this->query ($sql);
</pre>

						<br/>
						A relatively easy task with EmmaPHP.
						<br/><br/>
						Now let's say <b>you want to pass data to the query string</b>.<br/>
						We have the variables <span class="pink">$firstname</span> and <span class="pink">$lastname</span>.<br/>
						Let's send them to the Database now, shall we?<br/>
						<br/>
<pre>
$sql = "INSERT INTO users (firstname, lastname) "
     . "VALUES (?, ?);";

$this->query ($sql, array ($firstname, $lastname));
</pre>
<br/>
						In the above example we use the <span class="pink">?</span> placeholder.<br/>
						It serves as a placeholder for a variable.<br/>
						We pass an extra parameter with the <span class="pink">query ()</span> method we inherited from the <span class="pink">Base Model</span><br/>
						as an array holding all variables we want to pass with the query in the order of the placeholders.<br/>
						<br/>
						<b>The same applies for fetching and fetching all rows.</b><br/>
						<br/>
						Fetching:<br/><br/>
<pre>
$sql = "SELECT * FROM users WHERE firstname = ? AND lastname = ? LIMIT 1;";

$result = $this->fetch ($sql, array ($firstname, $lastname));
</pre>
						<br/>

						Fetching all:<br/><br/>
<pre>
$sql = "SELECT * FROM users WHERE group = ?;";

$result = $this->fetchAll ($sql, array ($group));
</pre>

<br/>
<h2><b>Data Objects</b></h2>

                        <br/>When you've given the <span class="pink">fetch ()</span> & <span class="pink">fetchAll ()</span> methods a swing,<br/>
                        You'll notice it doesn't return an array holding the data from the table you've been trying to get your hands on.<br/>
                        <br/>
                        Instead it returns an object that holds the data the same way an array does.<br/>
                        Lets say we ran the query on the above example, and this table named <span class="pink">users</span> has a column named <span class="pink">email</span>.<br/>
                        The return data from the method is obvicously stored in the <span class="pink">$result</span> variable so the way we'd fetch this email adres would be like this:<br/><br/>
<pre>
$result->email;
</pre>
                        <br/>
                        The <span class="pink">fetchAll ()</span> however does returns an array but within that array we got the same <span class="pink">Data Objects</span> like before.<br/>
                        If we were to fetch more users with <span class="pink">fetchAll ()</span> and we want all their emails displayed this is how we would do it.<br/><br/>
<pre>
foreach ($result as $user) {
    
    echo $user->email;

}
</pre>
                        <br/>
                        The best thing about <span class="pink">Data Objects</span> however is that it allows us to make hybrid methods in our models.<br/>
                        Let's say we have this method in our model named <span class="pink">UserModel</span>:<br/></br/>
<pre>

public function getUser ($id) {
    
    sql = "SELECT * FROM user WHERE id = ?;";

    $result = $this->fetch ($sql, array ($id));

    return $result ? $result : false;

}

</pre>
                        <br/>
                        This method allows us to fetch all data from a user.<br/>
                        Now when you only want to fetch let's say the email address, id or fullname<br/>
                        from someone we'd have to create a whole set of methods that do so.<br/>
                        However with <span class="pink">Data Objects</span> we can make this method hybrid by using it like so in our controller:<br/><br/>
<pre>

    //If you only want the email address from the column "email".
    $this->UserModel->getUser ($id)->email;

    //If you only want the fullname from the column "fullname".
    $this->UserModle->getUser ($id)->fullname;

    //If you only want the id from the column "id".
    $this->UserModle->getUser ($id)->id;

</pre>
                        <br/>Easy, right?
                        <br/><b>The usage of <span class="pink">Data Objects</span> allows us to write cleaner, more readable and maintainable code.</b><br/> 

                        <br/><h2><b>Using your homemade model</b></h2><br/>
                        So you've loaded in your model, now how do we use it?<br/>
                        Consider the following two files.<br/>
                        <br/>
                        <b>WelcomeController</b>
<pre>
class WelcomeController extends EmmaController {
    
    function __construct () {
        
        parent::__construct ();

        $this->load->model ("DataModel");
        
    }
    
    public function index() {
        
        if ($data = $this->DataModel->getData ()) {

            echo $data;

        }
        
    }
    
}
</pre><br/>
<br/>
                        <b>DataModel</b>
<pre>
class DataModel extends EmmaModel {
    
    function __construct() {
        
        parent::__construct();
        
    }
    
    public function getData() {
        
        $sql =    "SELECT information_string "
                . "FROM DATA "
                . "LIMIT 1;";
        
        $this->fetch ($sql);
        
        return $result ? $result->data_column : false;
        
    }

}
</pre><br/>
<br/>
                        After examinating the code you will notice that<br/>
                        a loaded model will be dynamically created into an object in the local scope.<br/>
                        You may access your homemade model instance through <span class="pink">$this->DataModel</span>, or whatever you named it.<br/>
                        <b>Note that your homemade models have public access modifiers,<br/>
                            so /do not/ forget to make sensetive data private.</b>
                        
                    </div>
                    <!--models end-->
                        
                    <!--views-->
                    <div id="views" class="ug_item">
                    
                        <h1 class="pink"><b>EmmaPHP::Views</b></h1>
                        <br/>
                        <h2><b>View creation</b></h2><br/>
                        Not a lot can be said about views,<br/>
                        they are your average HTML pages that the user sees.<br/>
                        they play a vital role in the MVC Architecture,<br/>
                        But nothing really changes about them.<br/>
                        Other than that you shouldn't forget to <br/>
                        echo the <span class="pink">TITLE</span> constant into the header like so:<br/>
                        <br/>
                        <pre>
&lt;head&gt;
    &lt;title&gt;&lt;?=TITLE;?&gt;&lt;/title&gt;
&lt;/head&gt;
                        </pre>
                        <br/>
                        <h2><b>Linking CSS & JavaScript</b></h2><br/>
                        Everything is ran from the <span class="pink">index.php</span><br/>
                        so linking your <span class="pink">CSS</span> files is done easily as following:<br/>
                        <br/>
                        <pre>
&lt;link href=&quot;assets/css/yourcssfile.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;
                        </pre>
                        <br/>
                        The same applies for <span class="pink">JavaScript</span> files.<br/>
                        <br/>
                        <pre>
&lt;script src=&quot;assets/scripts/yourjavascriptfile.js&quot;&gt;&lt;/script&gt;
                        </pre>
						<br/>
						If you for some reason still need a basepath variable to search for your file<br/>
						please do rely on the <span class="pink">BASEPATH</span> constant which can be used everywhere.
                        <br/><br/>
                        <h2><b>Loading views</b></h2><br/>
                        Loading views happens in the controller.<br/>
                        All views should be placed in the views directory<br/>
                        and from there on into the appropriate directory.<br/>
                        Feel free to create more subdirectories if you please to do so.<br/>
                        Consider the following code to load a view within a controller:<br/>
                        <br/>
                        <pre>
public function page($page = "welcome") {
        
    if( ! file_exists ("views/pages/" . $page . ".php")) {

        $this->show_404 ();

    } else {

        $this->load->view ("pages/" . $page . ".php");

    }

}</pre>
                        <br/>
                        After close examination of the above displayed code<br/>
                        you would notice that <span class="pink">$this->load->view ();</span> is the method that<br/>
                        supplies us with a way to return a <span class="pink">View</span> to the user through our <span class="pink">Controller</span>.<br/>
                        <br/>
                        It's good practice to first <b>check if the file exists before you return the <span class="pink"></span>View</b>.<br/>
                        This way you will be sure that the user isn't left with just<br/>
                        a blank screen or a confusing error should <span class="pink">debug mode</span> be on.
                        <br/>
                        You can easily see how we achieve this with use of the native <span class="pink">file_exists ()</span> function<br/>
                        and the <span class="pink">$this->show_404 ()</span> method supplied by our <span class="pink">BAseController</span>.<br/>
                        Also note how when making use of the <span class="pink">$this->load->view ()</span> function we supply a <span class="pink">.php</span><br/>
                        extension where as loading <span class="pink">Models</span> doesn't require us to supply a file extension.<br/>
                        This is done that way so that you may easily load both <span class="pink">PHP</span> and <span class="pink">HTML</span> files.<br/>
                        <br/>
                        <h2><b>Accessing data through views.</b></h2><br/>
                        Accessing data stored in your <span class="pink">Controller</span>'s class variables with your <span class="pink">View</span><br/>
                        for some reason has always been something done through <span class="pink">$data</span> variables.<br/>
                        If you've ever worked with <a href="https://ellislab.com/codeigniter"><span class="pink">CodeIgniter</span></a> you'll know what I'm talking about.<br/>
                        In <span class="pink">EmmaPHP</span> this is not the case.<br/>
                        Accessing data from our <span class="pink">Controller</span> and displaying it on our <span class="pink">View</span> is easily done like this:<br/><br/>
                        <span class="pink">Controller</span>
<pre>
class MyController extends EmmaController {

    protected $email;

    public function __construct () {

        parent::__construct ();

        $this->load->model ("UserModel");

    }

    public function index () {

        $this->email = $this->UserModel->getUser (1)->email;

    }

}
</pre><br><span class="pink">View</span>
<pre><code>
    &lt;p&gt;&lt;?=$this-&gt;email;?&gt;&lt;/p&gt;
</code></pre><br/>
                        That's right!<br/>
                        <span class="pink">Views</span> have scope access to the <span class="pink">Controllers</span> that loaded them in.<br/>
                        This allows for us to avoid any nasty <span class="pink">$data</span> variables that we have to pass through when we load views.<br/>
                        Clean, maintainable and readable code!.
                    </div>
                    <!--views end-->

					
					<!--parameters-->
					<div id="parameters" class="ug_item">
					
					<h1 class="pink"><b>EmmaPHP::Parameters</b></h1>
					<br/>
                    <h2><b>Parameters</b></h2>
                    <br/>
					Getting $_POST and $_GET variables goes via methods built into the base controller in <span class="pink">EmmaPHP</span>.<br/>
					They are always available and do not need to be loaded.<br/>
                    <br/>
                    <span class="pink">$this->getPost ()</span> and <span class="pink">$this->getGet ()</span> automatically filter the input with <span class="pink">FILTER_SANITIZE_FULL_SPECIAL_CHARS</span><br/>
                    <br/><br/>
                    <pre>
public function index () {

    if ($this->getPost ("login_submit")) {

        $this->login ($this->getPost ("username"), $this->getPost ("password"));

    }

    if ($username = $this->getGet ("username")) {

        $this->profile ($username);

    }

}
                    </pre>

					</div>
					<!--end parameters-->
                    
					<!--redirecting-->
					<div id="redirecting" class="ug_item">
						
						<h1 class="pink"><b>EmmaPHP::Redirecting</b></h1><br/>
						<h2><b>Redirecting</b></h2>
						<br/>
						For redirecting there again is a built in function in <span class="pink">EmmaPHP</span>.<br/>
						Redirecting is always done from out the base url.<br/>
						<br/>
						This would redirect to the <span class="pink">WelcomeControllers</span>'s method <span class="pink">page ()</span>.<br/>
						<br/>
						<pre>
$this->redirect ("?c=welcome&m=page");
						</pre>
<br/><br/>
						You may also pass an argument to the <span class="pink">page ()</span> method by adding <span class="pink">&a=about</span> to supply "about" as argument or anything else.
						

					</div>
					<!--end redirecting-->

					<div id="sessions" class="ug_item">

						<h1 class="pink"><b>EmmaPHP::Sessions</b></h1><br/>
						<h2><b>Starting the session</b></h2><br/>
						The session is automatically started at startup so there's no need to worry about that.<br/>
						<br/>
						<h2>Setting session variables</h2><br/>
						To set a session variable we would do the following.<br/><br/>
<pre>
$this->session->set ("email", catlover1337@cathost.cat);
</pre> 
<br/>
						This will set the session variable "email" to "catlover1337@cathost.cat".<br/><br/><br/>

						<h2>Getting session variables</h2><br/>

						Now to check if this variable is set and to fetch it we would do this.<br/><br/>

<pre>
if ($email = $this->session->get ("email")) {

	echo $email;

}
</pre>
<br/>
<br/>
					<h2>Remove/delete session variables</h2><br/>
					Done? here's how you nullify the session variable.<br/><br/>
<pre>
$this->session->nullify ("email");
</pre>
<br/><br/>
<img src="http://img4.wikia.nocookie.net/__cb20130209022103/adventuretimewithfinnandjake/images/thumb/f/f0/And_its_gone_original.jpg/500px-And_its_gone_original.jpg" />

					</div>

                    <div id="autoloader" class="ug_item">
                        <h1 class="pink"><b>EmmaPHP::Autoloader</b></h1><br/>
                        The autoloader is a System Component that automatically loads models into the controller.<br/>
                        All it requires is a little configuration done in the <span class="pink">config/config.php</span><br/>
                        All you need to do is put the names of the <span class="pink">model</span>'s class names into the array like so:<br/>
                        <br/>
<pre>
$autoload = array ("UserModel", "DataModel", "BikiniModel");
</pre>
                        <br/>
                        This will load the <span class="pink">UserModel</span>, the <span class="pink">DataModel</span> and the <span class="pink">BikiniModel</span> if they are present.<br/>
                        Don't load models that aren't existant for explosions are noisy.
                    </div>

                    <div id="security" class="ug_item">
                        <h1 class="pink"><b>EmmaPHP::Security</b></h1><br/>
                        Stereotypically girls can be quite insecure; <span class="pink">EmmaPHP</span> isn't.<br/>
                        The framework has a set of methods in the base controller specifically used for security.<br/>
                        The methods I speak of are the following;<br/>
                        <br/>
                        There's <span class="pink">$this->encrypt ()</span> which accepts a string to encrypt, it uses the SHA1 encryption method.<br/>
                        And then there's the <span class="pink">$this->generateSalt ()</span> method which generates a salt.<br/>
                        The salt is an encrypted string of 100 random pseudo bytes<br/>
                        because PHP's <span class="pink">rand ()</span> & <span class="pink">mt_rand ()</span> are not random enough.<br/>
                        <br/>
                        On the topic of security it is also very useful to know that <span class="pink">$this->getPost ()</span> and <span class="pink">$this->getGet ()</span><br/>
                        automatically filter the input with <span class="pink">FILTER_SANITIZE_FULL_SPECIAL_CHARS</span>

                    </div>

                    <div id="mods" class="ug_item">
                        <h1 class="pink"><b>EmmaPHP::Mods</b></h1><br/>

                        <span class="pink">EmmaPHP</span> also features <span class="pink">Mods</span>.<br/>
                        <span class="pink">Mods</span> are pretty much libraries though a little more powerful.<br/>
                        <br/>
                        <b>What is a mod</b><br/>
                        For something to be a <span class="pink">Mod</span> it just has to be a PHP class.<br/>
                        Any native PHP class will run perfectly fine within <span class="pink">EmmaPHP</span>.<br/>
                        Here's an example of a <span class="pink">Mod</span>:<br/><br/>
<pre>
    class EchoBack {

        public function echoBack ($string) {

            echo $string;

        }

    }
</pre>
                        <br/>
                        Now this is just an example and it isn't such a great <span class="pink">Mod</span>.<br/>
                        But this -- nonetheless -- is a perfectly fine <span class="pink">Mod</span>.<br/>
                        <br/>
                        A <span class="pink">Mod</span> can do anything.<br/>
                        <br/>
                        <b>How do I load a mod</b><br/>
                        Loading a <span class="pink">Mod</span> is terrifyingly simple.<br/>
                        All you have to do is drag it into the <span class="pink">Mods</span> folder and that's it,<br/>
                        done, the <span class="pink">Framework</span> will load it automatically.<br/>
                        <br/>
                        <b>But what /is/ the difference between a mod and a library?</b><br/>
                        The difference between a <span class="pink">Mod</span> is that it can be ran anywhere.<br/>
                        You could mod the entire <span class="pink">Framework</span> to bits using your <span class="pink">Mods</span>.<br/>
                        Literaly /anywhere/ in the code you can call to your mod after it's loaded in by the <span class="pink">Core</span>.<br/>
                        <br/>
                        Hence why it's named a <span class="pink">Mod</span>.<br/>
                        <br/>
                        <b>How to use my mod</b><br/>
                        Using a <span class="pink">Mod</span> is like using a class.<br/>
                        If I were to use the <span class="pink">Mod</span> I made earlier (<span class="pink">EchoBack</span>).<br/>
                        And I wanted to use it's method <span class="pink">echoBack ()</span> this is how I'd do it:<br/><br/>
<pre>
    EchoBack::echoBack ("Hello, Mods!");
</pre>
<br/>
                        It's that easy.<br/>
                        And remember, you can call a <span class="pink">Mod</span> anywhere after it's been loaded in by the <span class="pink">Core</span>.

                    </div>

                    </small>
                    
                    <!--this is so scrub of me but...-->
                    <br/><br/><br/><br/><br/><br/>
                    <!--no really this makes designers cry blood-->
                    
                </div>
                <!--section_2_content end-->
                
            </div>
            <!--section_2 end-->
            
        </div>
        <!--wrapper end-->
        
    </body>
</html>
